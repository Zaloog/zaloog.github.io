---
layout: post
author: Lars Grams
title:  a tui in a day
date:   2025-02-20
published: true
tags:   python, tui, textual, blueutil
---

# what is a TUI
A TUI is a **T**ext-based **U**ser **I**nterface, which provides another way of
interacting within the terminal besides writing plain text commands.
There are several frameworks to build such TUIs, e.g. [ratatui] for *Rust*
or [textual] for Python. In the following article I will describe the development of a TUI using
the [textual] framework.

# the issue
When switching from phone to macbook, my airpods would not automatically connect to the macbook.
Since opening the bluetooth settings and manually connecting them every time was quite annoying,
I looked for possibilities to control the bluetooth directly from terminal.
After some research I stumbled over [bluetui], which is only for *linux*, and [blueutil], which is
*macos* only.
[blueutil] offered all the functionalities I wanted, but I did not like to remember lenghty commands
or define aliases for them.


# the idea
Since I worked with the textual framework quite a lot for my recent projects, I decided to
build a simple TUI, which acts as a wrapper around [blueutil].
The features I wanted where pretty simple:
- should display bluetooth devices and their status in a table
- should support vimlike navigation with j/k
- should support pairing/connecting/searching of devices

I also decided to use [textuals][textual] inline mode (currently not supported on windows),
which opens the TUI directly under your prompt without occupying the whole screen.


# building the app
Based on the features described above I went for a pretty minimal app, which is composed from three widgets.
First `Header` to display the app title and the current installed version of [blueutil]. Then the
main part of the app, the `DeviceTable`, which is just a custom class, that inherits from [textuals][textual]
`DataTable` widget and finally the `Footer` to show the keybindings and how to control the app.

```python
class BlueUtilApp(App):
    def on_mount(self):
        self.get_blueutil_version()

    def compose(self) -> ComposeResult:
        self.screen.title = "blueutil-tui"
        yield Header(icon="")
        yield DeviceTable()
        yield Footer()
        return super().compose()

    @work(thread=True)
    def get_blueutil_version(self):
        version = get_blueutil_version()
        self.screen.title += f" using blueutil v{version}"

```

Before starting with the `DeviceTable` definition I had to get the information
about my bluetooth devices from [blueutil] and then use that information to
display it inside a [textual] DataTable. [blueutil] provides the option to display the device data as a *.json*.
```bash
$ blueutil --paired --format json-pretty
[
  {
    "address" : "f0-04-e1-db-ea-42",
    "recentAccessDate" : "2025-02-20T14:28:06+01:00",
    "paired" : true,
    "RSSI" : 0,
    "rawRSSI" : 0,
    "favourite" : false,
    "connected" : true,
    "name" : "AirPods Pro",
    "slave" : false
  },
  {
    ...
  }
]
```
So I could use `subprocess.run` to execute the command
and capture the string output and parse it with `json.loads` into a list of dictionaries.

```python
def get_paired_devices() -> list[dict[str, str | bool]] | None:
    command = subprocess.run(
        ["blueutil", "--paired", "--format", "json"],
        capture_output=True,
        text=True,
        timeout=TIMEOUT,
    )

    handle_returncodes(errorcode=command.returncode)

    if command.stdout:
        devices = command.stdout
        formatted_devices = format_device_string(device_string=devices)
        return formatted_devices

def format_device_string(device_string: str) -> list[dict[str, str | bool]]:
    json_dict = json.loads(device_string)
    return json_dict
```

Then I could define the function that updates the DataTable widget. It clears the table
then iterates over the list of devices to insert the
`address`, `name`, `recentAccessDate` and `pairing` and `connection` status as
new rows into the [textual] DataTable Widget.


```python
class DeviceTable(DataTable):

    ...

    def action_update_devices(self):
        self.clear()
        devices = get_paired_devices()
        for device in devices:
            self.add_row(
                ":green_circle:" if device["connected"] else ":red_circle:",
                ":green_circle:" if device["paired"] else ":red_circle:",
                device["recentAccessDate"],
                device["address"],
                key=device["address"],
                label=f"[blue]{device['name']}[/]",
            )
```

To enable vimlike navigation, I had to redefine some of the bindings for the DataTable widget.
Since there already are `cursor_down`, `cursor_up` and `select_cursor` actions defined, I did not have to create a custom
action for the navigations.

```python
class DeviceTable(DataTable):
    BINDINGS = [
        Binding("j, down", "cursor_down", "down", key_display="j/↓"),
        Binding("k, up", "cursor_up", "up", key_display="k/↑"),
        Binding("space, enter", "select_cursor", "dis/connect", key_display="space/enter"),
        Binding("r", "update_devices", "refresh"),
        Binding("s", "display_new_devices", "search"),
        Binding("p", "toggle_pair_device", "un/pair"),
    ]

```

The last three bindings, which handle the interaction with [blueutil] required the definition
of new actions though. For example the binding to refresh the table is triggered when pressing
`r`, calls the `action_update_devices` function from above and is displayed as `refresh` in the Footer.

One of the harder parts was updating the device status and updating the app view accordingly without blocking
the main event loop in which the app runs. This is possible in [textual] using the worker API (see [docs][textual-worker]).

# the result
Putting it all together, I am pretty happy how it turned out.
![image](https://raw.githubusercontent.com/Zaloog/blueutil-tui/main/images/preview.png)

The initial [blueutil-tui]-app as you see it here was created on a single day.
The next days I fixed some bugs, regarding the searching of new devices
and also added a timer label which appears, when searching.

<!-- Links -->

[textual]: https://textual.textualize.io
[ratatui]: https://ratatui.rs

[bluetui]: https://github.com/pythops/bluetui
[blueutil]: https://github.com/toy/blueutil
[blueutil-tui]: https://github.com/Zaloog/blueutil-tui

[textual-worker]: https://textual.textualize.io/guide/workers/
