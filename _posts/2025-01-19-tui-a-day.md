---
layout: post
author: Lars Grams
title:  a tui in a day
date:   2025-02-20
published: true
tags:   python, tui, textual, blueutil
---

# what is a TUI
A TUI is a **T**ext-based **U**ser **I**nterface, which provides another way of
interacting within the terminal besides writing plain text commands.
There are several frameworks to build such TUIs, e.g. [ratatui] for *Rust*
or [textual] for Python. In the following article I will describe the development of a TUI using
the [textual] framework.

# the issue
When switching from phone to macbook, my airpods would not automatically connect to the macbook.
Since opening the bluetooth settings and manually connecting them every time was quite annoying,
I looked for possibilities to control the bluetooth directly from terminal.
After some research I stumbled over [bluetui], which is only for *linux*, and [blueutil], which is
*macos* only.
[blueutil] offered all the functionalities I wanted, but I did not like to remember lenghty commands
or define aliases for them.


# the idea
Since I worked with the textual framework quite a lot for my recent projects, I decided to
build a simple TUI, which acts as a wrapper around some [blueutil] commands.
Here are the features I wanted, and how I decided to implement it:


- **Feature 1**: The app shall have an easy overview to show my paired devices and their status.
    - **How**: DataTable Widget with a single row per device. A clear label to identify
    devices, aswell as red and green circles to display connection and pairing status.

- **Feature 2**: The app shall support fast and easy navigation and controls without needing the mouse. 
    - **How**: Let the app start in inline mode (not supported on windows currently) to open the tui directly
    under the prompt. Also overwrite/add additional bindings to DataTable Widget
    for vimlike navigation with j/k and other functionalities.
    Also utilize workers to not block the apps main event loop.

- **Feature 3**: The app shall support un/pairing, dis/connecting of devices and searching for new unpaired devices. 
    - **How**: Define the necessary functions, bindings to trigger them and table cell updates.

- **Feature 4**: The app should indicate, that its currently searching for new devices. 
    - **How**: Add a label to indicate that search is running. Including timer to show how much time is left.



# building the app
Based on the features described above I went for a pretty minimal app, which is composed from three widgets.
First a `Header` to display the app title and the current installed version of [blueutil]. Then the
main part of the app, the `DeviceTable`, which is just a custom class, that inherits from [textuals][textual]
`DataTable` widget and finally the `Footer` to show the keybindings to control the app.

```python
class BlueUtilApp(App):
    def on_mount(self):
        self.get_blueutil_version()

    def compose(self) -> ComposeResult:
        self.screen.title = "blueutil-tui"
        yield Header(icon="")
        yield DeviceTable()
        yield Footer()
        return super().compose()

    @work(thread=True)
    def get_blueutil_version(self):
        version = get_blueutil_version()
        self.screen.title += f" using blueutil v{version}"

```

Before starting with the `DeviceTable` definition I had to get the information
about the bluetooth devices from [blueutil] and then use that information to
display it inside a [textual] DataTable. [blueutil] provides the option to display the device data in *.json*-format.
```bash
$ blueutil --paired --format json-pretty
[
  {
    "address" : "f0-04-e1-db-ea-42",
    "recentAccessDate" : "2025-02-20T14:28:06+01:00",
    "paired" : true,
    "RSSI" : 0,
    "rawRSSI" : 0,
    "favourite" : false,
    "connected" : true,
    "name" : "AirPods Pro",
    "slave" : false
  },
  {
    ...
  }
]
```
So I could use `subprocess.run` to execute the command
and capture the string output and parse it with `json.loads` into a list of dictionaries.

```python
def get_paired_devices() -> list[dict[str, str | bool]] | None:
    command = subprocess.run(
        ["blueutil", "--paired", "--format", "json"],
        capture_output=True,
        text=True,
        timeout=TIMEOUT,
    )

    handle_returncodes(errorcode=command.returncode)

    if command.stdout:
        devices = command.stdout
        formatted_devices = format_device_string(device_string=devices)
        return formatted_devices

def format_device_string(device_string: str) -> list[dict[str, str | bool]]:
    json_dict = json.loads(device_string)
    return json_dict
```

Then I could define the function that updates the DataTable widget. It clears the table
then iterates over the list of devices to insert the
`address`, `name`, `recentAccessDate` and `pairing` and `connection` status as
new rows into the [textual] DataTable Widget.


```python
class DeviceTable(DataTable):

    ...

    def action_update_devices(self):
        self.clear()
        devices = get_paired_devices()
        for device in devices:
            self.add_row(
                ":green_circle:" if device["connected"] else ":red_circle:",
                ":green_circle:" if device["paired"] else ":red_circle:",
                device["recentAccessDate"],
                device["address"],
                key=device["address"],
                label=f"[blue]{device['name']}[/]",
            )
```

To enable vimlike navigation, I had to redefine some of the bindings for the DataTable widget.
Since there already are `cursor_down`, `cursor_up` and `select_cursor` actions defined, I did not have to create a custom
action for the navigations.

```python
class DeviceTable(DataTable):
    BINDINGS = [
        Binding("j, down", "cursor_down", "down", key_display="j/↓"),
        Binding("k, up", "cursor_up", "up", key_display="k/↑"),
        Binding("space, enter", "select_cursor", "dis/connect", key_display="space/enter"),
        Binding("r", "update_devices", "refresh"),
        Binding("s", "display_new_devices", "search"),
        Binding("p", "toggle_pair_device", "un/pair"),
    ]

```

The last three bindings, which handle the interaction with [blueutil] required the definition
of new actions though. For example the binding to refresh the table is triggered when pressing
`r`, calls the `action_update_devices` function from above and is displayed as `refresh` in the Footer.

One of the harder parts was updating the device status and updating the app view accordingly without blocking
the main event loop in which the app runs. This is possible in [textual] using the worker API (see [docs][textual-worker]).

```python
class DeviceTable(DataTable):

    ...

    @on(DataTable.RowSelected)
    @work(thread=True)
    async def toggle_connection(self, event: DataTable.RowSelected):
        selected_address = event.row_key.value

        self.app.call_from_thread(
            lambda: self.update_cell(
                row_key=selected_address,
                column_key="connection",
                value="updating...",
            )
        )
        # disconnecting
        if await device_is_connected(device_address=selected_address):

            output = await disconnect_device(device_address=selected_address)
            # disconnecting successfull
            if output == 0:
                self.app.call_from_thread(
                    lambda: self.update_cell(
                        row_key=selected_address,
                        column_key="connection",
                        value=":red_circle:",
                    )
                )
                self.notify(
                    title="Success",
                    message=f"[blue]{self.rows[selected_address].label}[/] disconnected",
                    timeout=1.5,
                )
            # error while disconnecting
            else:
                self.app.call_from_thread(
                    lambda: self.update_cell(
                        row_key=selected_address,
                        column_key="connection",
                        value=":green_circle:",
                    )
                )
                self.notify(
                    title="Error",
                    message=f"Please check [blue]{self.rows[selected_address].label}[/] if the device is nearby",
                    timeout=1.5,
                    severity="error",
                )
    ...

```

This function gets triggered, if we select a row/device in our DeviceTable.
It updates the corresponding field in the DeviceTable to an *updating...* string,
checks if the device is connected, and then either
connects the unconnected device or disconnects the connected device, and updates the table entry accordingly.
If the return value of the `disconnect_device`/ `connect_device` function is non-zero, i.e. if an error occured,
it updates the DeviceTable field to the previous value and displays an error notification.

The same functionality is also implemented for pairing devices, which can be triggered pressing `p` on the corresponding
device row in the table.

# the result
Putting it all together, I am pretty happy how it turned out.
![image](https://raw.githubusercontent.com/Zaloog/blueutil-tui/main/images/preview.png)

The initial [blueutil-tui]-app as you see it here was created on a single day.
The next days I fixed some bugs, regarding the searching of new devices
and also added a timer label which appears, when searching.

<!-- Links -->

[textual]: https://textual.textualize.io
[ratatui]: https://ratatui.rs

[bluetui]: https://github.com/pythops/bluetui
[blueutil]: https://github.com/toy/blueutil
[blueutil-tui]: https://github.com/Zaloog/blueutil-tui

[textual-worker]: https://textual.textualize.io/guide/workers/
